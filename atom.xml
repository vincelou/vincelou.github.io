<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kanggggg.github.io</id>
    <title>Kanggggg</title>
    <updated>2020-04-10T08:24:04.143Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kanggggg.github.io"/>
    <link rel="self" href="https://kanggggg.github.io/atom.xml"/>
    <subtitle>Hello world</subtitle>
    <logo>https://kanggggg.github.io/images/avatar.png</logo>
    <icon>https://kanggggg.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Kanggggg</rights>
    <entry>
        <title type="html"><![CDATA[[iOS]使用正则表达式的正确姿势]]></title>
        <id>https://kanggggg.github.io/post/iosshi-yong-zheng-ze-biao-da-shi-de-zheng-que-zi-shi</id>
        <link href="https://kanggggg.github.io/post/iosshi-yong-zheng-ze-biao-da-shi-de-zheng-que-zi-shi">
        </link>
        <updated>2020-01-19T09:30:13.000Z</updated>
        <summary type="html"><![CDATA[<p>在iOS开发过程中，正则的使用还是比较常见，用来判断用户名、手机号等的输入。当碰到这种需求的时候，部分开发的第一印象可能是使用 <code>NSPredicate</code> 的 <code>SELF MATCHES %@</code> 进行判断，但遗憾的是此方法并非万能，存在检查不出来的情况。其实苹果专门提供了 <code>NSRegularExpression</code> 这个类来做正则校验。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在iOS开发过程中，正则的使用还是比较常见，用来判断用户名、手机号等的输入。当碰到这种需求的时候，部分开发的第一印象可能是使用 <code>NSPredicate</code> 的 <code>SELF MATCHES %@</code> 进行判断，但遗憾的是此方法并非万能，存在检查不出来的情况。其实苹果专门提供了 <code>NSRegularExpression</code> 这个类来做正则校验。</p>
<!-- more -->
<h2 id="初始化nsregularexpression">初始化NSRegularExpression</h2>
<pre><code class="language-objectivec">/// 初始化NSRegularExpression，如果出错则会返回nil，并带有error
/// @param pattern 正则表达式
/// @param options 模式选项，一般设成 kNilOptions
/// @parma error 错误
+ (nullable NSRegularExpression *)regularExpressionWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error;
</code></pre>
<h3 id="关于nsregularexpressionoptions">关于NSRegularExpressionOptions</h3>
<pre><code class="language-objectivec">typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) {
   NSRegularExpressionCaseInsensitive             = 1 &lt;&lt; 0, //不区分字母大小写的模式
   NSRegularExpressionAllowCommentsAndWhitespace  = 1 &lt;&lt; 1, //忽略掉正则表达式中的空格和#号之后的字符
   NSRegularExpressionIgnoreMetacharacters        = 1 &lt;&lt; 2, //将正则表达式整体作为字符串处理
   NSRegularExpressionDotMatchesLineSeparators    = 1 &lt;&lt; 3, //允许.匹配任何字符，包括换行符  
   NSRegularExpressionAnchorsMatchLines           = 1 &lt;&lt; 4, //允许^和$符号匹配行的开头和结尾
   NSRegularExpressionUseUnixLineSeparators       = 1 &lt;&lt; 5, //设置\n为唯一的行分隔符，否则所有的都有效。
   NSRegularExpressionUseUnicodeWordBoundaries    = 1 &lt;&lt; 6 //使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效
};
</code></pre>
<p>前面提到 options 一般设成 <code>kNilOptions</code>，它的效果就是区分大小写，严格校验。需要区分大小写的时候把options 设成 <code>NSRegularExpressionCaseInsensitive</code>，结果就是正则 <code>abc</code> 会匹配到 abc 也会匹配到 ABC。</p>
<h2 id="匹配">匹配</h2>
<h3 id="获取匹配的个数">获取匹配的个数</h3>
<pre><code class="language-objectivec">NSString *regEx = @&quot;&lt;正则表达式&gt;&quot;;
NSString *string = @&quot;&lt;待匹配的字符串&gt;&quot;;
NSError *error;
NSRegularExpression *regularExpression = [NSRegularExpression regularExpressionWithPattern:regEx options:kNilOptions error:&amp;error];
if (error) {
    NSLog(@&quot;error = %@&quot;, error);
}

NSUInteger number = [regularExpression numberOfMatchesInString:string options:kNilOptions range:NSMakeRange(0, string.length)];
NSLog(@&quot;匹配的个数 = %lu&quot;, (unsigned long)number);
</code></pre>
<h3 id="获取第一个匹配的结果">获取第一个匹配的结果</h3>
<pre><code class="language-objectivec">NSString *regEx = @&quot;&lt;正则表达式&gt;&quot;;
NSString *string = @&quot;&lt;待匹配的字符串&gt;&quot;;
NSError *error;
NSRegularExpression *regularExpression = [NSRegularExpression regularExpressionWithPattern:regEx options:kNilOptions error:&amp;error];
if (error) {
    NSLog(@&quot;error = %@&quot;, error);
}

NSTextCheckingResult *firstMatch = [regularExpression firstMatchInString:string options:0 range:NSMakeRange(0, string.length)];
if (firstMatch) {
    // NSTextCheckingResult 的 range 属性即匹配的字符串的位置
    NSString *matchedString = [string substringWithRange:firstMatch.range];
    NSLog(@&quot;匹配的字符串 = %@&quot;, matchedString);       
}
</code></pre>
<h3 id="获取所有匹配的结果">获取所有匹配的结果</h3>
<pre><code class="language-objectivec">NSString *regEx = @&quot;&lt;正则表达式&gt;&quot;;
NSString *string = @&quot;&lt;待匹配的字符串&gt;&quot;;
NSError *error;
NSRegularExpression *regularExpression = [NSRegularExpression regularExpressionWithPattern:regEx options:kNilOptions error:&amp;error];
if (error) {
    NSLog(@&quot;error = %@&quot;, error);
}

NSArray *matchArray = [regularExpression matchesInString:string options:0 range:NSMakeRange(0, string.length)];
for (NSTextCheckingResult *match in matchArray) {
    NSString *matchedString = [string substringWithRange:match.range];
    NSLog(@&quot;匹配的字符串 = %@&quot;, matchedString); 
}
</code></pre>
<h3 id="替换匹配的字符串">替换匹配的字符串</h3>
<pre><code class="language-objectivec">NSString *regEx = @&quot;&lt;正则表达式&gt;&quot;;
NSString *string = @&quot;&lt;待匹配的字符串&gt;&quot;;
NSString *replacingString = @&quot;&lt;替换的字符串&gt;&quot;;
NSError *error;
NSRegularExpression *regularExpression = [NSRegularExpression regularExpressionWithPattern:regEx options:kNilOptions error:&amp;error];
if (error) {
    NSLog(@&quot;error = %@&quot;, error);
}

NSString *newString = [regularExpression stringByReplacingMatchesInString:string options:kNilOptions range:NSMakeRange(0, string.length) withTemplate:replacingString];
NSLog(@&quot;替换后的字符串 = %@&quot;, newString); 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[iOS]WKWebView下JS alert()/confirm()/prompt() 失效解决方案]]></title>
        <id>https://kanggggg.github.io/post/ios-kai-fa-zhi-wkwebview-xia-js-alertconfirmprompt-shi-xiao-jie-jue-fang-an</id>
        <link href="https://kanggggg.github.io/post/ios-kai-fa-zhi-wkwebview-xia-js-alertconfirmprompt-shi-xiao-jie-jue-fang-an">
        </link>
        <updated>2020-01-17T10:33:39.000Z</updated>
        <summary type="html"><![CDATA[<p>由于苹果的安全机制，苹果拦截了JavaScript的alert()/confirm()/prompt()的弹出，需要实现 <code>WKUIDelegate</code> 的下面三个代理方法：</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于苹果的安全机制，苹果拦截了JavaScript的alert()/confirm()/prompt()的弹出，需要实现 <code>WKUIDelegate</code> 的下面三个代理方法：</p>
<!-- more -->
<pre><code class="language-objectivec">// 对应 alert()
// 如果不实现这个方法，就相当于用户选择了OK
- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler;

// 对应 confirm()
// 如果不实现这个方法，就相当于与用户选择cancel
- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler;

// 对应 prompt()
// 如果不实现这个方法，就相当于与用户选择cancel
- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable result))completionHandler;
</code></pre>
<p>具体实现：</p>
<pre><code class="language-objectivec">// alert()
- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler {
  
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:message preferredStyle:UIAlertControllerStyleAlert];
    [alertController addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        
        completionHandler();
    }]];
    [self presentViewController:alertController animated:YES completion:nil];
}

// confirm()
- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler {
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:message preferredStyle:UIAlertControllerStyleAlert];
    [alertController addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        completionHandler(NO);
    }]];
    [alertController addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        completionHandler(YES);
    }]];
    [self presentViewController:alertController animated:YES completion:nil];
}

// prompt()
- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable result))completionHandler {
    
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:prompt preferredStyle:UIAlertControllerStyleAlert];
    [alertController addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {
       textField.text = defaultText;
    }];
    [alertController addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        completionHandler(nil);
    }]];
    [alertController addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
       }]];
    [self presentViewController:alertController animated:YES completion:nil];
}
</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[iOS]CocoaPods：插件篇一 CocoaPods Packager]]></title>
        <id>https://kanggggg.github.io/post/ios-kai-fa-zhi-cocoapodscha-jian-pian-yi-cocoapods-packager</id>
        <link href="https://kanggggg.github.io/post/ios-kai-fa-zhi-cocoapodscha-jian-pian-yi-cocoapods-packager">
        </link>
        <updated>2019-09-19T06:10:06.000Z</updated>
        <summary type="html"><![CDATA[<p>经过我们的不懈努力，CocoaPods的私有库写完了，现在进入集成阶段了，倘若对方工程也在使用CocoaPods，我们也乐意开放源码，那就是开心愉快了，倘若对方工程还是个老古董，我们也不乐意开放源码，这时候就需要我们自行打包了。我们也知道打包又要考虑架构考虑真机和模拟器，很繁琐，CocoaPods Packager就可以来拯救我们。</p>
]]></summary>
        <content type="html"><![CDATA[<p>经过我们的不懈努力，CocoaPods的私有库写完了，现在进入集成阶段了，倘若对方工程也在使用CocoaPods，我们也乐意开放源码，那就是开心愉快了，倘若对方工程还是个老古董，我们也不乐意开放源码，这时候就需要我们自行打包了。我们也知道打包又要考虑架构考虑真机和模拟器，很繁琐，CocoaPods Packager就可以来拯救我们。</p>
<!-- more -->
<p><a href="https://guides.cocoapods.org/plugins/using-pods-for-closed-source-libs.html">Packaging Closed Source SDKs</a><br>
<a href="https://github.com/CocoaPods/cocoapods-packager">CocoaPods Packager</a></p>
<blockquote>
<p>CocoaPods plugin which allows you to generate a framework or static library from a podspec.</p>
<p>This plugin is for CocoaPods developers, who need to distribute their Pods not only via CocoaPods, but also as frameworks or static libraries for people who do not use Pods.</p>
</blockquote>
<h2 id="安装">安装</h2>
<p>打开终端，执行下面命令：</p>
<pre><code class="language-bash">$ gem install cocoapods-packager

# 安装完成之后，验证一下，也可用来查看帮助
$ pod package
</code></pre>
<h2 id="命令说明">命令说明</h2>
<pre><code class="language-bash"># Overwrite existing files.
# 是否覆盖已存在的文件
--force 

# Do not mangle symbols of depedendant Pods.
--no-mangle

# Generate embedded frameworks. 
# 生成静态Framework
--embedded

# Generate static libraries.
# 生成静态Library
--library

# Generate dynamic framework. 
# 生成动态Framework
--dynamic

# Bundle identifier for dynamic framework
# 动态Framework Bundle identifier
--bundle-identifier 

# Exclude symbols from dependencies.
# 不包含依赖的符号表，动态库不能包含这个命令
--exclude-deps 

# Build the specified configuration (e.g. Debug). Defaults to Release
# 生成的库是Debug还是Release，默认是Release。--configuration=Debug 
--configuration

# Only include the given subspecs
# 只给指定的子库打包
--subspecs

# The sources to pull dependant pods from (defaults to https://github.com/CocoaPods/Specs.git)
# 存在私有依赖
--spec-sources=private,https://github.com/CocoaPods/Specs.git 
</code></pre>
<h2 id="example">Example</h2>
<pre><code class="language-bash">$ cd 工程目录
$ pod package MyLib.podspec --force --embedded --no-mangle --exclude-deps --configuration=DEBUG
</code></pre>
<p>这边提供一个懒人方法，把命令写成Shell可执行文件放在目录下，就不用每次都敲命令了：</p>
<ol>
<li>
<p>新建 <code>package.sh</code> 文件放在跟podspec同目录下，输入：</p>
<pre><code class="language-bash">#!/bin/bash
pod package MyLib.podspec --force --embedded --no-mangle --exclude-deps --configuration=DEBUG
</code></pre>
</li>
<li>
<p>给予可执行权限</p>
<pre><code class="language-bash">$ chmod u+x package.sh
</code></pre>
</li>
<li>
<p>执行</p>
<pre><code class="language-bash">$ cd 项目目录
$ ./package.sh
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[iOS]CocoaPods：进阶篇 搭建私有库]]></title>
        <id>https://kanggggg.github.io/post/ios-kai-fa-zhi-cocoapodsjin-jie-pian-da-jian-si-you-ku</id>
        <link href="https://kanggggg.github.io/post/ios-kai-fa-zhi-cocoapodsjin-jie-pian-da-jian-si-you-ku">
        </link>
        <updated>2019-09-19T06:09:11.000Z</updated>
        <summary type="html"><![CDATA[<p>经过入门篇中的实操，我们现在已经安装好了CocoaPods，也知道怎么导入依赖库了， 现在开始向前进一步，利用CocoaPods搭建私有库。</p>
<p>其实像AFNetworking这样的库，我们可以用CocoaPods导入是因为CocoaPods官方维护了一套库。那么其实我们也可以自己维护一套私有库，只供我们自己使用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>经过入门篇中的实操，我们现在已经安装好了CocoaPods，也知道怎么导入依赖库了， 现在开始向前进一步，利用CocoaPods搭建私有库。</p>
<p>其实像AFNetworking这样的库，我们可以用CocoaPods导入是因为CocoaPods官方维护了一套库。那么其实我们也可以自己维护一套私有库，只供我们自己使用。</p>
<!-- more -->
<h2 id="创建pod项目工程">创建Pod项目工程</h2>
<p>为什么Pod项目工程中的代码可以被导入？就像AFNetworking这个工程中的代码可以被我们导入，主要是因为项目中的podspec文件。</p>
<blockquote>
<p>A specification describes a version of Pod library. It includes details about where the source should be fetched from, what files to use, the build settings to apply, and other general metadata such as its name, version, and description.<br>
规范描述了Pod库的一个版本。 它包括有关应从何处获取源，要使用的文件，要应用的构建设置以及其他常规元数据（如名称，版本和说明）的详细信息。</p>
</blockquote>
<p>创建Pod项目工程有两个方法：</p>
<ol>
<li>
<p>手动创建podspec文件，这个方法更适合于把已有项目转为Pod项目</p>
<pre><code class="language-bash">$ pod spec creare [库名]
</code></pre>
</li>
<li>
<p>自动创建Pod项目工程，这个方法更适于一个Pod项目从无到有</p>
<pre><code class="language-bash">$ pod lib create [库名]
</code></pre>
</li>
</ol>
<p>方法2创建的工程，会包含Demo工程，我自己更倾向使用此方法来做Pod。</p>
<h3 id="pod-lib-create">pod lib create</h3>
<p><a href="https://guides.cocoapods.org/making/using-pod-lib-create.html">Using Pod Lib Create</a></p>
<p><code>pod lib create</code> 是Pod提供的一个自动化创建私有pod工程的命令，实质上是下载一个Pod工程模板到本地，再做修改。命令在运行过程中，会弹出几个配置项进行配置，按需设置就行，很简单。</p>
<pre><code class="language-bash">$ cd ~/Desktop
$ pod lib create MyUtils
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481388198669.jpg" alt="" loading="lazy"></figure>
<p>项目目录如下：</p>
<figure data-type="image" tabindex="2"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481388489415.jpg" alt="" loading="lazy"></figure>
<ul>
<li>Example：Demo工程目录</li>
<li>MyUtils：库代码目录</li>
<li>LICENSE：开源证书</li>
<li>MyUtils.podspec：库的podspec</li>
<li>README.md：Readme</li>
</ul>
<p>双击 <strong>MyUtils.xcworkspace</strong> 打开工程，工程结构如下：</p>
<figure data-type="image" tabindex="3"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481391868339.jpg" alt="" loading="lazy"></figure>
<p>接下来，我把这个工程放到了GitHub。</p>
<h2 id="编写库代码">编写库代码</h2>
<p>我这里就写一个测试类 <code>MUAppInfo</code>，写完之后再 <code>pod install</code> 进行开发模式下的导入</p>
<p><strong>MUAppInfo.h</strong></p>
<figure data-type="image" tabindex="4"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481397736154.jpg" alt="" loading="lazy"></figure>
<p><strong>MUAppInfo.m</strong></p>
<figure data-type="image" tabindex="5"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481397856966.jpg" alt="" loading="lazy"></figure>
<p><strong>MUViewController.h</strong></p>
<figure data-type="image" tabindex="6"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481399293405.jpg" alt="" loading="lazy"></figure>
<h2 id="编辑podspec">编辑podspec</h2>
<ul>
<li><a href="https://guides.cocoapods.org/syntax/podspec.html#specification">Podspec Syntax Reference</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking.podspec">AFNetworking.podspec</a></li>
<li><a href="http://blog.csdn.net/wadefelix/article/details/6384317">如何选择开源许可证？</a></li>
</ul>
<p>podspec是这个pod的配置文件，当我们引用这个pod到工程的时候，就会按这个文件里的配置项进行配置。这边顺便提一下，podspec是Ruby文件，我们可以用 <a href="https://code.visualstudio.com/">Visual Studio Code</a> 再装上Ruby插件来编辑，真的很好用。</p>
<p>我对这个测试Pod的podspec做了简单编辑，具体配置项这里不细说了，可以查看<a href="https://guides.cocoapods.org/syntax/podspec.html#specification">Podspec Syntax Reference</a>：</p>
<pre><code class="language-ruby">Pod::Spec.new do |s|
  s.name             = 'MyUtils'
  s.version          = '0.1.0'
  s.summary          = 'A short description of MyUtils.'

  s.homepage         = 'https://github.com/kanggggg/MyUtils'
  s.license          = { :type =&gt; 'MIT', :file =&gt; 'LICENSE' }
  s.author           = { 'Kang' =&gt; 'xxxxx@gmail.com' }
  s.source           = { :git =&gt; 'https://github.com/kanggggg/MyUtils.git', :tag =&gt; s.version.to_s }

  s.ios.deployment_target = '8.0'
  s.source_files = 'MyUtils/Classes/**/*'
end
</code></pre>
<h3 id="验证pod是否可用">验证Pod是否可用</h3>
<p>podspec写好了，接下来需要验证是否正确，这里有两个方法：</p>
<pre><code class="language-ruby"># pod spec lint 会去校验 s.source 的配置，也就是会去拉代码验证
$ pod spec lint # 不指定，默认当前文件夹内的podspec
$ pod spec lint MyUtils.podspec # 指定podspec

# pod lib lint 忽略 s.source 的配置，本地代码验证
$ pod lib lint # 不指定，默认当前文件夹内的podspec
$ pod lib lint MyUtils.podspec # 指定podspec
</code></pre>
<p>当看到终端打印 <code>passed validation.</code> ，就说明验证通过，不通过就根据提示进行修改。</p>
<p>当验证通过之后，打上tag，推送到远程仓库</p>
<pre><code>$ git tag 0.1.0
$ git push origin --tags # 推送到远程
</code></pre>
<h2 id="创建私有specs-repo">创建私有Specs repo</h2>
<p>我们先打 <code>./cocoapods/repos</code> 文件夹，会看到里面有个master文件夹，该目录即存放着官方的spec。我们自己添加的spec repo也会放在 <code>./cocoapods/repos</code> 文件夹下。</p>
<ol>
<li>
<p>先创建一个git仓库，<code>https://github.com/kanggggg/MySpecs</code></p>
</li>
<li>
<p>添加到本地 <code>repos</code> 目录</p>
<pre><code class="language-bash">$ pod repo add MySpecs https://github.com/kanggggg/MySpecs.git
</code></pre>
</li>
</ol>
<h3 id="把私有pod添加到私有-specs-repo-中">把私有Pod添加到私有 Specs repo 中</h3>
<pre><code class="language-bash">$ pod repo push MySpecs MyUtils.podspec
</code></pre>
<p>添加成功之后，就能看到 <code>~/.cocoapods/repos/MySpecs</code> 多了 <code>MyUtils</code>，<code>MySpecs</code> 的远程仓库同步更新了。</p>
<h3 id="测试工程导入私有库">测试工程导入私有库</h3>
<p>这里拿出上面的 CocoaPodsDemo 这个工程进行测试，编辑Podfile ，编辑完成之后执行install</p>
<figure data-type="image" tabindex="7"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481447599235.jpg" alt="" loading="lazy"></figure>
<p>这里的重点在要指定source：</p>
<pre><code class="language-ruby"># 官方
source 'https://github.com/CocoaPods/Specs.git'

# 私有
source 'https://github.com/kanggggg/MySpecs.git'
</code></pre>
<h2 id="私有库使用问答">私有库使用问答</h2>
<h3 id="私有库依赖私有库时验证不过">私有库依赖私有库时验证不过</h3>
<p>这个时候需要指定sources</p>
<pre><code class="language-bash">$ pod spec lint &lt;库名&gt;.podspec --sources='私有Specs repo仓库地址,https://github.com/CocoaPods/Specs.git'

# 比如
# pod spec lint MyUtils.podspec --sources='https://github.com/kanggggg/MySpecs.git,https://github.com/CocoaPods/Specs.git'
</code></pre>
<h3 id="私有库依赖私有库推送到私有specs-repo">私有库依赖私有库，推送到私有Specs repo</h3>
<pre><code class="language-bash">$ pod repo push &lt;私有repo&gt; &lt;库名&gt;.podspec --sources='私有Specs repo仓库地址,https://github.com/CocoaPods/Specs.git'

# 比如
# pod repo push MySpecs MyUtils.podspec 
</code></pre>
<h3 id="pod验证过程中发现修改的不生效">pod验证过程中，发现修改的不生效</h3>
<p>我们在验证pod的时候，可能会频繁的修改，但是有的时候修改了却还是之前的样子，再或者我们总是拉不到最新的代码老是老版本的，我们可以试着去清理缓存</p>
<pre><code class="language-bash"># 查看缓存
$ pod cache list

# 清理全部缓存
$ pod cache clean --all
</code></pre>
<h3 id="私有库依赖的其他三方library或者framework不支持i386导致-pod-lib-lint一直过不了报-ld-symbols-not-found-for-architecture-i386">私有库依赖的其他三方library或者framework，不支持i386，导致 <code>pod lib lint</code>一直过不了，报 <code>ld: symbol(s) not found for architecture i386</code></h3>
<p>这个问题真的是很令人头疼，折腾了两天，也看了网上的一些解决办法，包括StackOverFlow，有成功的也有不成功的，成功的我也觉得不是最佳。我就去翻CocoaPods GitHub Issues，终于让我翻到了。</p>
<ul>
<li><a href="https://github.com/CocoaPods/CocoaPods/issues/8129">Undefined symbols for architecture i386 even though it's omitted from VALID_ARCHS #8129</a></li>
<li><a href="https://github.com/CocoaPods/CocoaPods/pull/8159">Fix linting when armv7 is included but i386 isn't #8159</a></li>
</ul>
<p>8129这个问题在 CocoaPods 1.6.0.beta.2 版本得到了修复</p>
<ol>
<li>
<p>先升级到CocoaPods Beta版</p>
<pre><code class="language-bash">$ sudo gem install -n /usr/local/bin cocoapods --pre
</code></pre>
</li>
<li>
<p>编辑podspec，加入 pod_target_xcconfig</p>
<pre><code class="language-ruby">s.pod_target_xcconfig = { 'VALID_ARCHS' =&gt; 'arm64 armv7 x86_64' }
</code></pre>
<p>什么是 <a href="https://guides.cocoapods.org/syntax/podspec.html#pod_target_xcconfig">pod_target_xcconfig</a> ?</p>
<blockquote>
<p>Any flag to add to the final private pod target xcconfig file.<br>
要添加到最终私有pod目标xcconfig文件的任何标志。</p>
</blockquote>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[iOS]CocoaPods：入门篇 管理依赖库]]></title>
        <id>https://kanggggg.github.io/post/ios-kai-fa-zhi-cocoapodsru-men-pian-guan-li-yi-lai-ku</id>
        <link href="https://kanggggg.github.io/post/ios-kai-fa-zhi-cocoapodsru-men-pian-guan-li-yi-lai-ku">
        </link>
        <updated>2019-09-19T06:07:29.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>WHAT IS COCOAPODS<br>
CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 52 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.</p>
</blockquote>
<p><a href="https://cocoapods.org/">CocoaPods</a> 官网上的这段话翻译一下就是：CocoaPods是Swift和Objective-C Cocoa项目的依赖管理器。他拥有超过52000个库，并在超过300万个应用程序中使用。CocoaPods可以帮助您优雅地扩展项目。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>WHAT IS COCOAPODS<br>
CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 52 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.</p>
</blockquote>
<p><a href="https://cocoapods.org/">CocoaPods</a> 官网上的这段话翻译一下就是：CocoaPods是Swift和Objective-C Cocoa项目的依赖管理器。他拥有超过52000个库，并在超过300万个应用程序中使用。CocoaPods可以帮助您优雅地扩展项目。</p>
<!-- more -->
<p>简单来说，就是可以帮助你方便地导入三方库，并导入库的依赖，免去了手动完成三方库导入配置。除了导入，你还可以利用CocoaPods搭建你自己的私有库体系。因为这些功能，CocoaPods基本上所有iOS开发者必用的。那么现在就从如何使用CocoaPods管理依赖库开始入门。</p>
<h2 id="安装">安装</h2>
<p>CocoaPods是使用Ruby构建的，所以需要在本地准备好Ruby环境。不过Mac默认已经有了Ruby环境，可以免去搭建Ruby环境了，但是还需要进行简单配置。打开终端（Terminal），我们开始操作。</p>
<h3 id="第一步-更换rubygems源">第一步 更换RubyGems源</h3>
<p>RubyGems在国内的访问速度极其感人，所以要进行更换，换成国内的镜像源。我使用的是 <a href="https://gems.ruby-china.com/">Ruby China</a> 的源。</p>
<ol>
<li>
<p>查看当前的源，默认情况下我们能看到当前的源是 <code>https://rubygems.org</code></p>
<pre><code class="language-bash">$ gem sources -l
</code></pre>
</li>
<li>
<p>移除当前源，并添加新的源</p>
<pre><code class="language-bash"># Ruby China有https和http两种源，我一开始添加的是https的源会报SSL错误，改成了http就没问题
$ gem sources --add http://gems.ruby-china.com/ --remove https://rubygems.org/
</code></pre>
</li>
<li>
<p>再次查看当前源，这个时候就变成了 <code>http://gems.ruby-china.com/</code></p>
<pre><code class="language-bash">$ gem sources -l
</code></pre>
</li>
</ol>
<h3 id="第二步-安装cocoapods">第二步 安装CocoaPods</h3>
<ol>
<li>
<p>安装，执行完下面的命令，等待一会就好</p>
<pre><code class="language-bash">$ sudo gem install cocoapods

# Mac OS X EI Capitan 以后系统请用下面这个安装命令
$ sudo gem install -n /usr/local/bin cocoapods

# 安装指定版本
$ sudo gem install -n /usr/local/bin cocoapods -v 1.7.4

# 安装Beta版
$ sudo gem install -n /usr/local/bin cocoapods --pre
</code></pre>
<p>这里提一下，如何卸载呢？</p>
<pre><code class="language-bash">$ sudo gem uninstall cocoapods
</code></pre>
</li>
<li>
<p>查看pod版本，验证是否安装成功</p>
<pre><code class="language-bash">$ pod --version
</code></pre>
</li>
<li>
<p>在安装完成之后，进行设置。这一步的主要作用就是把官方的Specs repo (<a href="https://github.com/CocoaPods/Specs">The CocoaPods Master Repo</a>) 拉到本地，本地的存放目录是 <code>~/.cocoapods/repos/master</code></p>
<pre><code class="language-bash">$ pod setup
</code></pre>
<p>何为Sepec repo? 以AFNetworking举例，AFNetworking在CocoaPods体系中，它是一个Pod，每一个Pod都有一个podspec文件，这个文件指定了Pod的版本、源码、公共头文件、依赖等等。那么Specs repo里就存有所有官方的podspec（官方是xxx.podspec.json，私有的是xxx.podspec）</p>
<p><strong>友情提醒1，这一步很慢很慢，请耐心等待</strong><br>
<strong>友情提醒2，如果你很没有耐心，你可以偷懒从其他安装好了CocoaPods的电脑上，拷贝一份repos到你的电脑上</strong></p>
</li>
</ol>
<h2 id="cocoapods管理依赖库">CocoaPods管理依赖库</h2>
<p>经过上面的折腾，CocoaPods已经安装成功了，我们要用来管理依赖库了。下面以CocoaPodsDemo工程导入AFNetworking进行演示。</p>
<h3 id="第一步-创建podfile">第一步 创建Podfile</h3>
<p>终端进入工程目录，新建Podfile，并编辑</p>
<pre><code class="language-bash">$ cd ~/Desktop/CocoaPodsDemo/
$ pod init # 在工程目录下创建Podfile文件
$ vi Podfile # 编辑
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481240442711.jpg" alt="" loading="lazy"></figure>
<p>编辑Podfile，初始文件内容如下图。这里直接用的vi编辑器，不知如何使用的，请点<a href="http://www.runoob.com/linux/linux-vim.html">Linux vi/vim</a></p>
<figure data-type="image" tabindex="2"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481245106076.jpg" alt="" loading="lazy"></figure>
<h3 id="第二步-引入依赖">第二步 引入依赖</h3>
<figure data-type="image" tabindex="3"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481237443868.jpg" alt="" loading="lazy"></figure>
<p>AFNetworking GitHub的这段话告诉我们，我们要想导入，要编辑Podfile，指定要导入它。但是这时候我们还不能直接编辑，因为我们要确定一下是否真的支持导入AFNetworking。</p>
<pre><code class="language-bash">$ pod search AFNetworking
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481263983217.jpg" alt="" loading="lazy"></figure>
<p>search的结果告诉我们，确实支持导入AFNetworking，当前的最新版是3.2.1，还有很多历史版本可以导入，AFNetworking里还有子库。现在可以来编辑Podfile：</p>
<figure data-type="image" tabindex="5"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481249314614.jpg" alt="" loading="lazy"></figure>
<p>编辑完成之后，执行下面命令完成导入：</p>
<pre><code class="language-bash">$ pod install
</code></pre>
<p>导入完成之后，Xcode打开工程的时候不再使用 <strong>CocoapodsDemo.xcodeeproj</strong>，使用 <strong>CocoaPods.xcworkspace</strong> 打开工程，此时的工程目录如下图：</p>
<figure data-type="image" tabindex="6"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481250903053.jpg" alt="" loading="lazy"></figure>
<h2 id="podfile">Podfile</h2>
<p><a href="https://guides.cocoapods.org/syntax/podfile.html">Podfile Syntax Reference</a></p>
<blockquote>
<p>The Podfile is a specification that describes the dependencies of the targets of one or more Xcode projects.</p>
</blockquote>
<p>Podfile是一个描述一个或多个Xcode项目的目标依赖项的规范，更直白的说就是指定项目要导入什么依赖，并指定一些导入设置。</p>
<p>接下来简单分析一下CocoaPodsDemo这个工程里的Podfile：</p>
<figure data-type="image" tabindex="7"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481258803893.jpg" alt="" loading="lazy"></figure>
<p>这里指定工程所支持的最低系统版本</p>
<figure data-type="image" tabindex="8"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481259105045.jpg" alt="" loading="lazy"></figure>
<p>这里指定是否以动态库的形式编译Pods</p>
<ul>
<li><code># use_frameworks</code> 是以Static Library的形式编译</li>
<li><code>use_frameworks</code> 默认是以Dynamic Framework的形式编译</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://myblog-image.oss-cn-shanghai.aliyuncs.com/15481260080281.jpg" alt="" loading="lazy"></figure>
<p>这里指定要导入的依赖，这里的写法有很多种。</p>
<pre><code class="language-ruby">pod 'AFNetworking'
</code></pre>
<p>例子中的这种写法，指定导入最新版的AFNetworking。我们也可以指定版本号：</p>
<pre><code class="language-ruby">pod 'AFNetworking', '~&gt;3.2.1'
</code></pre>
<h2 id="更多pod使用以及脱坑">更多Pod使用以及脱坑</h2>
<h3 id="pod-install-很慢怎么办">pod install 很慢怎么办?</h3>
<pre><code class="language-bash">$ pod install --verbose --no-repo-update
</code></pre>
<p>每次 <code>pod install</code> 的时候，都会去更新repo，但是速度又很慢，这条命令可以直接跳过更新</p>
<h3 id="目前工程导入了多个依赖如何更新依赖如何更新指定依赖">目前工程导入了多个依赖，如何更新依赖，如何更新指定依赖？</h3>
<pre><code class="language-bash">$ pod update # 更新所有依赖
$ pod update AFNetworking # 只更新AFNetworking
</code></pre>
<p><code>pod update</code> 也会更新repo，速度很慢，所以也可以这样跳过更新：</p>
<pre><code class="language-bash">$ pod update AFNetworking --verbose --no-repo-update
</code></pre>
<h3 id="如何更新repo">如何更新repo?</h3>
<pre><code class="language-bash">$ pod repo update
</code></pre>
<h3 id="pod报cocoapods-was-not-able-to-update-the-master-repo">pod报CocoaPods was not able to update the `master` repo</h3>
<pre><code class="language-bash">#第一步 删除缓存
$ sudo rm -fr ~/Library/Caches/CocoaPods/

#第二步 清空本地Repos
$ sudo rm -fr ~/.cocoapods/repos/master/

#第三部 重新setup
$ pod setup
</code></pre>
<h3 id="pod-search-报错-unable-to-find-a-pod-with-name-author-summary-or-descriptionmatching-json">pod search 报错 [!] Unable to find a pod with name, author, summary, or descriptionmatching <code>JSON</code></h3>
<pre><code class="language-bash">#第一步 删除search_index.json
$ rm ~/Library/Caches/CocoaPods/search_index.json

#第二步 重新search
$ pod search JSON
</code></pre>
<h3 id="安装pods失败提示ruby版本过低这需要去升级ruby这里采用rvm方式升级">安装Pods失败，提示Ruby版本过低，这需要去升级Ruby（这里采用RVM方式升级）</h3>
<pre><code class="language-bash"># 第一步 安装RVM
$ curl -L get.rvm.io | bash -s stable

# 第二步 安装成功之后
$ source ~/.bashrc
$ source ~/.bash_profile
$ rvm -v # 查看RVM版本

# 第三步 升级Ruby
# 查看现有Ruby版本
$ ruby -v

# 列出可安装的版本
$ rvm list known

# 安装最新版
$ rvm install 2.3.0
</code></pre>
<h3 id="gem版本过老">gem版本过老</h3>
<pre><code class="language-bash">#升级gem
$ sudo gem update --system

#查看gem版本
$ gem --version
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Mac]开发环境之NPM]]></title>
        <id>https://kanggggg.github.io/post/mac-kai-fa-huan-jing-zhi-npm</id>
        <link href="https://kanggggg.github.io/post/mac-kai-fa-huan-jing-zhi-npm">
        </link>
        <updated>2019-09-19T06:06:13.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.npmjs.com">NPM</a> 即 Node Package Manager，是NodeJS的包管理器，且是随同NodeJS一起安装的。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.npmjs.com">NPM</a> 即 Node Package Manager，是NodeJS的包管理器，且是随同NodeJS一起安装的。</p>
<!-- more -->
<ul>
<li><a href="https://nodejs.org/en/">Node.js 官网</a></li>
<li><a href="http://nodejs.cn">Node.js 中文网</a></li>
</ul>
<h2 id="安装">安装</h2>
<pre><code class="language-bash"># Homebrew安装Node
$ brew install node
</code></pre>
<h2 id="基本使用">基本使用</h2>
<pre><code class="language-bash">$ npm help &lt;term&gt; # 查看&lt;term&gt;帮助，exp. npm help install 查看install的帮助
$ npm ls [-g] # 查看安装的模块及依赖，option：[-g]全局
$ npm root [-g] #查看node_modules的路径，option：[-g]全局

# 安装包
$ npm install &lt;packageNmae&gt; [-g] # 安装，option：[-g]全局
$ npm uninstall &lt;packageNmae&gt; # 卸载
$ npm update &lt;packageNmae&gt; # 更新
</code></pre>
<p>以安装Hexo为例：</p>
<pre><code class="language-bash">$ npm install hexo [-g] # 安装，option：[-g]全局
$ npm uninstall hexo # 卸载
$ npm update hexo # 更新
</code></pre>
<h2 id="注意">注意</h2>
<ol>
<li>
<p>包下载不下来，需要更换源</p>
<pre><code class="language-bash">$ npm config set registry https://registry.npm.taobao.org --global
$ npm config set disturl https://npm.taobao.org/dist --global
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Mac]开发环境之Ruby]]></title>
        <id>https://kanggggg.github.io/post/mac-kai-fa-huan-jing-zhi-ruby</id>
        <link href="https://kanggggg.github.io/post/mac-kai-fa-huan-jing-zhi-ruby">
        </link>
        <updated>2019-09-19T06:04:46.000Z</updated>
        <content type="html"><![CDATA[<p>Mac默认已经集成了Ruby环境，但是时间长了，难免版本过旧需要更新。</p>
<h2 id="rvm">RVM</h2>
<blockquote>
<p>RVM is a command-line tool which allows you to easily install, manage, and work with multiple ruby environments from interpreters to sets of gems.</p>
</blockquote>
<p><a href="http://www.rvm.io/">RVM</a> 即 Ruby Version Manager，它是一套命令行工具，可用来方便地安装、管理、切换Ruby环境。</p>
<ul>
<li><a href="https://ruby-china.org/">Ruby China</a></li>
</ul>
<h3 id="安装rvm">安装RVM</h3>
<pre><code class="language-bash"># 先安装RVM
$ curl -L get.rvm.io | bash -s stable

# 安装成功之后
$ source ~/.bashrc  
$ source ~/.bash_profile 

# 查看RVM版本
$ rvm -v
</code></pre>
<h3 id="基本使用">基本使用</h3>
<pre><code class="language-bash"># 查看现有Ruby版本
$ ruby -v

# 列出可安装的版本
$ rvm list known

# 安装版本
$ rvm install 2.3.0

# 切换版本
$ rvm use 2.3.0

# 设置默认版本
$ rvm use 2.3.0 --default

# 列出已安装的版本
$ rvm list

# 删除版本
$ rvm remove 2.3.0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Mac]开发环境之Homebrew]]></title>
        <id>https://kanggggg.github.io/post/mac-kai-fa-huan-jing-zhi-homebrew</id>
        <link href="https://kanggggg.github.io/post/mac-kai-fa-huan-jing-zhi-homebrew">
        </link>
        <updated>2019-09-19T06:02:57.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://brew.sh/index_zh-cn.html">Homebrew</a> ，macOS缺失的软件包管理器。实际上手之后，你会发现真的是不可获缺的，能方便地帮助我们完成包的安装、更新、卸载等等。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://brew.sh/index_zh-cn.html">Homebrew</a> ，macOS缺失的软件包管理器。实际上手之后，你会发现真的是不可获缺的，能方便地帮助我们完成包的安装、更新、卸载等等。</p>
<!-- more -->
<h2 id="安装">安装</h2>
<pre><code class="language-bash">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<h2 id="基本使用">基本使用</h2>
<pre><code class="language-bash">$ brew update # 更新Homebrew
$ brew -v # 查看Homebrew版本
$ brew help [COMMAND] # 查看帮助

# 包
$ brew list # 查看已安装的包
$ brew search &lt;packageName&gt; # 查询可用包
$ brew install &lt;packageName&gt; # 安装包
$ brew uninstall &lt;packageName&gt; # 卸载包
$ brew upgrade &lt;packageName&gt; # 更新包
$ brew info &lt;packageName&gt; # 查看包信息
</code></pre>
<p>以安装git为例：</p>
<pre><code class="language-bash">$ brew search git # 查询
$ brew install git # 安装
$ brew uninstall git # 卸载
$ brew upgrade git # 更新
</code></pre>
<h2 id="一些好用的插件">一些好用的插件</h2>
<ul>
<li>快速预览增强
<ul>
<li>代码高亮：<code>brew cask install qlcolorcode</code></li>
<li>查看无文件扩展名的纯文本文件：<code>brew cask install qlstephen</code></li>
<li>Markdown文件预览：<code>brew cask install qlmarkdown</code></li>
<li>查看 JSON 文件：<code>brew cask install quicklook-json</code></li>
<li>预览CSV: <code>brew cask install quicklook-csv</code></li>
<li>查看图片的分辨率及大小：<code>brew cask install qlimagesize</code></li>
<li>查看 ZIP 压缩包文件：<code>brew cask install betterzip</code></li>
<li>预览WebP图片：<code>brew cask install webpquicklook</code></li>
<li>预览视频：<code>brew cask install qlvideo</code></li>
</ul>
</li>
<li>Android文件传输：<code>brew cask install android-file-transfer</code></li>
</ul>
<h2 id="注意">注意</h2>
<ol>
<li>
<p>错误提示 <code>Error: The /usr/local directory is not writable</code></p>
<pre><code class="language-bash">$ sudo chown -R $(whoami):admin /usr/local
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Mac]开发工具之更强大的终端 iTerm2+Oh My Zsh]]></title>
        <id>https://kanggggg.github.io/post/mac-kai-fa-gong-ju-zhi-geng-qiang-da-de-zhong-duan-iterm2oh-my-zsh</id>
        <link href="https://kanggggg.github.io/post/mac-kai-fa-gong-ju-zhi-geng-qiang-da-de-zhong-duan-iterm2oh-my-zsh">
        </link>
        <updated>2019-09-19T05:41:37.000Z</updated>
        <summary type="html"><![CDATA[<p>在开发过程中，难免要用到终端运行命令的情况，一般Mac自带能满足需求了，但是俗话说工欲善其事必先利其器，作为一个开发，没有理由拒绝把终端变得更强。iTerm2 搭配 Oh My Zsh 或许就是答案。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在开发过程中，难免要用到终端运行命令的情况，一般Mac自带能满足需求了，但是俗话说工欲善其事必先利其器，作为一个开发，没有理由拒绝把终端变得更强。iTerm2 搭配 Oh My Zsh 或许就是答案。</p>
<!-- more -->
<h2 id="iterm2">iTerm2</h2>
<p><a href="https://www.iterm2.com/index.html">iTerm2</a></p>
<blockquote>
<p>iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with macOS 10.12 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.</p>
</blockquote>
<p>安装的过程就不说了，下载下来，移动到Applications目录就好</p>
<p>在安装完成之后，你的终端就可以使用zsh了，Mac终端默认是使用bash，所以需要切换到zsh</p>
<pre><code class="language-bash">$ chsh -s /bin/zsh
</code></pre>
<h3 id="关于zsh和bash">关于zsh和bash</h3>
<p>zsh和bash都是一种shell，那么何为shell？</p>
<p><a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#bash">鸟哥的Linux私房菜 第十一章、认识与学习 BASH</a></p>
<p>总结一下就是shell是壳，是用户与系统内核沟通的命令行解析器，再通俗点说其实也是一个应用，只是它是文字形式的，要做什么必须输入文字命令。</p>
<p>那么Mac支持有几种shell呢？</p>
<pre><code class="language-bash"># 查看支持的shell
$ cat /etc/shells

# 切换shell
$ chsh -s /bin/zsh

# 查看当前的shell
$ echo $SHELL
</code></pre>
<p>常见shell如下：</p>
<ul>
<li><code>/bin/sh</code>：Bourne shell，被 <code>bash</code> 取代</li>
<li><code>/bin/bash</code>：Bourne-Again Shell，用来替代Bourne shell，多数Linux以及MacOS的默认shell</li>
<li><code>/bin/ksh</code>：<a href="http://www.kornshell.com/info/">Korn shell</a>，兼容bash</li>
<li><code>/bin/csh</code>：语法类似C语言</li>
<li><code>/bin/tcsh</code>：csh增强版</li>
<li><code>/bin/zsh</code>：基于ksh，功能更强大的shell，很多其他shell的特点都被引入zsh</li>
</ul>
<h2 id="oh-my-zsh">Oh My Zsh</h2>
<p><a href="https://ohmyz.sh">Oh My Zsh</a><br>
<a href="https://github.com/robbyrussell/oh-my-zsh/">Oh My Zsh GitHub</a></p>
<blockquote>
<p>Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout...</p>
<p>“Oh My ZSH!”</p>
</blockquote>
<p>一句话，Oh My Zsh 是对zsh的功能扩展</p>
<h3 id="安装">安装</h3>
<ol>
<li>
<p>自动安装</p>
<pre><code class="language-bash">$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>
</li>
<li>
<p>手动安装</p>
<pre><code class="language-bash">$ git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
$ cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre>
</li>
</ol>
<h3 id="配置">配置</h3>
<p>oh-my-zsh的配置文件是 <code>~/.zshrc</code>，每次变动了该文件，都需要 <code>source ~/.zshrc</code> 使配置生效</p>
<h3 id="插件">插件</h3>
<p>自带插件目录 <code>~/.oh-my-zsh/plugins</code>，也就是 <code>$ZSH/plugins</code><br>
三方插件目录 <code>~/.oh-my-zsh/custom/plugins</code>，也就是 <code>$ZSH_CUSTOM/plugins</code></p>
<h4 id="zsh-autosuggestions-命令补全">zsh-autosuggestions 命令补全</h4>
<p><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></p>
<ol>
<li>下载到三方插件目录，<code>$ git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</code></li>
<li>编辑 <code>~/.zshrc</code> ，加入到 <code>plugins</code> ，<code>plugins=(... zsh-autosuggestions)</code></li>
<li>使配置生效，<code>source ~/.zshrc</code></li>
</ol>
<h4 id="zsh-syntax-highlighting-语法高亮">zsh-syntax-highlighting 语法高亮</h4>
<p><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></p>
<ol>
<li>下载到三方插件目录，<code>$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</code></li>
<li>编辑 <code>~/.zshrc</code>，加入到 <code>plugins</code>，<code>plugins=(... zsh-syntax-highlighting)</code></li>
<li>在 <code>~/.zshrc</code> 的末尾加上 <code>source $ZSH_CUSTOM/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code></li>
<li>使配置生效，<code>source ~/.zshrc</code></li>
</ol>
<h3 id="主题">主题</h3>
<p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes">主题列表</a></p>
<p>自带主题目录 <code>~/.oh-my-zsh/themes</code>，也就是 <code>$ZSH/themes</code><br>
三方主题目录 <code>~/.oh-my-zsh/custom/themes</code>，也就是 <code>$ZSH_CUSTOM/themes</code></p>
<p>设置主题的方法（以设置ys主题为例）：</p>
<ol>
<li>编辑 <code>~/.zshrc</code>，设置 <code>ZSH_THEME=&quot;ys&quot;</code></li>
<li>使配置生效，<code>source ~/.zshrc</code></li>
</ol>
<h4 id="agnoster">agnoster</h4>
<p>这个主题应该是网上比较常提到的主题，虽然也是自带的，不过配置这个主题相对麻烦些</p>
<ol>
<li>
<p>安装Poweline</p>
<pre><code class="language-bash">$ sudo easy_install pip # 安装pip，若已安装可忽略
$ pip install powerline-status --user
</code></pre>
</li>
<li>
<p>安装PowerFonts</p>
<pre><code class="language-bash">$ mkdir PowerFonts
$ cd PowerFonts
$ git clone https://github.com/powerline/fonts.git --depth=1
$ cd fonts
$ ./install.sh
$ cd ..
$ rm -rf fonts
</code></pre>
</li>
<li>
<p>修改iTerm2字体，<code>iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text</code> ，把字体设成 <code>Meslo LG</code>，比如 <code>Meslo LG S for Powerline</code></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Mac]疑难杂症之安装App时提示已损坏解决办法]]></title>
        <id>https://kanggggg.github.io/post/mac-yi-nan-za-zheng-zhi-jie-jue-an-quan-yu-yin-si-mei-you-yun-xu-ren-he-lai-yuan-xuan-xiang</id>
        <link href="https://kanggggg.github.io/post/mac-yi-nan-za-zheng-zhi-jie-jue-an-quan-yu-yin-si-mei-you-yun-xu-ren-he-lai-yuan-xuan-xiang">
        </link>
        <updated>2019-09-19T05:28:42.000Z</updated>
        <summary type="html"><![CDATA[<p>由于MacOS的安全机制，非AppStore下载的App在打开的时候有时会提示App已损坏，怎么办呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于MacOS的安全机制，非AppStore下载的App在打开的时候有时会提示App已损坏，怎么办呢？</p>
<!-- more -->
<p>这个时候就需要进到 <em>系统偏好设置 -&gt; 安全性与隐私</em> 里设置允许从以下位置下载的App成任何来源。但是任何来源这个选项默认是被系统隐藏的。</p>
<h2 id="解决办法">解决办法</h2>
<h3 id="开启允许任何来源">开启允许任何来源</h3>
<ol>
<li>
<p>打开终端Terminal</p>
</li>
<li>
<p>输入命令</p>
<pre><code class="language-bash">$ sudo spctl --master-disable
</code></pre>
</li>
<li>
<p>如果没见效，重启就好</p>
</li>
</ol>
<h3 id="mac-catalina">Mac Catalina</h3>
<p>MacOS Catalina 更新之后，哪怕把允许任何来源都开启了，还会提示App已损坏，这时候就需要再打开终端，执行下面的命令：</p>
<pre><code class="language-bash">$ sudo xattr -d com.apple.quarantine /Applications/xxx.app
</code></pre>
]]></content>
    </entry>
</feed>